#import Queue
import threading
import json
#import time

class JSONParser (threading.Thread):
	def __init__(self, threadID, q, qLock, db, json_file):
		threading.Thread.__init__(self)
		self.threadID = threadID
		self.q = q
		self.db = db
		self.json = {}
		self.qLock = qLock
		self.input = json_file

	def run(self):
		print "** Starting", self.name
		self.process_data(self.q, self.qLock ,self.db)
		print "** Exiting", self.name

	def process_data(self, q, qLock, db):
		self.parse_file(q, qLock, db)
		self.fill_queue(q, qLock, db)

	def fill_queue(self, q, qLock,db):
		qLock.acquire()
		for router, transaction_type in db.iteritems():
			for transaction in transaction_type.keys():
				q.put((router, transaction))
		qLock.release()

	def parse_file(self, q, qLock, db):
		json_txt = ""
		local_key_map = {}
		lineNr = 0
		
		with open(self.json_file) as fp:
			for line in fp:
				json_txt += line
				
		tmp_db = json.loads(json_txt)
		self.json = tmp_db
		# Typical line in router should look like:
		# [ router1, router2, ...... ]
		# where each is 
		# [ .... , 
		#	{	"router_id": 0, "session_id": 2511, "session_type": "L2_DRAM", "response_ts": 0.000449854, 
		#	"request_ts": 0.000449374, "request_out_port": 2, "response_out_port": 2 }, ...... ]
		
		
		# Start constructing database with the following heirarchy:
		# db[ROUTER_ID][TRANSACTION_TYPE] = { "x": [....], "y": [.....] }
		# where:	x is the time the transaction returned
		# 			y is the delta between arrival and return
		
		db = {}
		
		for router in tmp_db:
			current_key = "router_"+router[0]["router_id"];
			qLock.acquire()
			q.put(current_key)
			qLock.release()
			db[current_key] = {}
			for entry in router:
				transaction_type = entry["session_type"]
				
				if transaction_type not in db[current_key]:
					db[current_key][transaction_type] = {"x":[], "y":[]} 
				
				y = entry["response_ts"] - entry["request_ts"]
				x = entry["response_ts"]
				
				db[current_key][transaction_type]["x"].append(x)
				db[current_key][transaction_type]["y"].append(y)  
			
		
		
		
		with open(vecfile,"r") as fp:
			state = 0
			lastSeg = -1
			for line in fp:
				lineNr = lineNr + 1
#				if lineNr%100000 == 0:
#					print "Reading line Nr:", lineNr
				if "session-phases" in line:
					state = 1
					elements = line.split()
					path = elements[3].split('_') # extract type of transaction from statistics variable name
					if(len(path)>1):
						path = path[-1] # global/l1_l2/l2_l3
					else:
						path = "NA"

					statistic_id = elements[1] 			# Vector ID
					statistic_router_name = elements[2][0:-7]	# Router associated
					statistic_type = path				# Type of stat (l1_l2/l2_l3/global)

					local_key_map[statistic_id] = (statistic_router_name, statistic_type) # Map internal ID to database entries
	
					if statistic_router_name not in db: 	# Create entry for router
						db[statistic_router_name] = {}

					if statistic_type not in db[statistic_router_name]: # Create entry for statistic type
						db[statistic_router_name][statistic_type] = { "x": [], "y": [] }
				else:
					if state == 1:
						state = 2
					if state == 2:
						segments = line.split()
						if segments[0] in local_key_map:
							#Add new XY
							router_name, path = local_key_map[segments[0]] # Translate internal id to DB
							x = float(segments[2])
							y = float(segments[3])
							db[router_name][path]["x"].append(x) # t_2 
							db[router_name][path]["y"].append(y) # delta_t

