#!/usr/bin/python
# -*- Mode: Python; indent-tabs-mode: t; c-basic-offset: 4; tab-width: 4 -*- 
#
# main.py
# Copyright (C) 2013 HNOCS <hnocs@hnocs-sim>
# 
# python-grapher is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# python-grapher is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along
# with this program.  If not, see <http://www.gnu.org/licenses/>.

#import numpy as np
#import matplotlib.pyplot as plt
#import matplotlib.mlab as mlab
import sys
from os import path
import Queue
import threading
import time
import AnalysisThread
#import VecParser
import JSONParser
import sys

import pygtk
import gtk
from matplotlib.figure import Figure
from matplotlib.backends.backend_gtkagg import FigureCanvasGTKAgg as FigureCanvas
from matplotlib.backends.backend_gtkagg import NavigationToolbar2GTKAgg as NavigationToolbar




database = {}
qLock = threading.Lock()
workQ = Queue.Queue() # TODO- this shouldn't be finite
threads = []
#figQ = Queue.Queue()
#figLock = threading.Lock()

if(len(sys.argv) != 3):
	print "Error", sys.argv
	print sys.argv[0] + " <vec-file-with path> <output-dir>"
	exit(-1)

if( not (path.isfile(sys.argv[1])  ) ):
	print "Error: file not found"
	print sys.argv
	print sys.argv[0] + " <vec-file-with path> <output-dir>"
	exit(-1)

input_file = path.expanduser(sys.argv[1])
outdir = path.expanduser(sys.argv[2])

#parser = VecParser.VecParser(0, workQ, qLock, database, input_file)
#parser.run() # Block until done
parser = JSONParser.JSONParser(0, workQ, qLock, database, input_file)
parser.run()

at = AnalysisThread.AnalyzeGraph(1, workQ, qLock, database, outdir)

data = parser.entries[0]
entry = database[data[0]][data[1]]







winwin = gtk.WindowGroup()
winwin.connect("destroy", lambda x: gtk.main_quit())
winwin.set_default_size(800,600)
winwin.set_title("WindowGroup")




win = gtk.Window()
win.connect("destroy", lambda x: gtk.main_quit())
win.set_default_size(800,600)
win.set_title("Embedding in GTK")

vbox = gtk.VBox()
win.add(vbox)

ax = at.average_analysis(entry, data[0], data[1])
fig = ax.get_figure()

ax.plot()
canvas = FigureCanvas(fig)  # a gtk.DrawingArea
vbox.pack_start(canvas)
toolbar = NavigationToolbar(canvas, win)
vbox.pack_start(toolbar, False, False)

##### Create a list of all DB Entries underneath
wn_entries = gtk.Window()
vb_entries = gtk.VBox()
l1 = gtk.Label("Moo")
l2 = gtk.Label("Boo")

vb_entries.add(l2)
vb_entries.add(l1)

wn_entries.add(vb_entries)
wn_entries.show_all()

win.show_all()


###################
winwin.add_window(win)
winwin.add_window(wn_entries)

winwin.
gtk.main()




exit(0)
#Belo wpart wou;d generate everything
for i in xrange(1, AnalysisThread.MaximumThreads):
	thread = AnalysisThread.AnalyzeGraph(i, workQ, qLock, database, outdir)
	thread.start()
	threads.append(thread)



# Check if we consumed all jobs
waitForQ = True
while waitForQ:
	qLock.acquire()
	waitForQ = not workQ.empty()
	qLock.release()
	time.sleep(1)

# If we got here, no more jobs left
for t in threads:
	t.exitFlag = True

for t in threads:
	t.join()
	
while not workQ.empty():
	print workQ.get()
	
print "Died...."

